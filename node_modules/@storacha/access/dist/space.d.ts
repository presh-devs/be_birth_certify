export function generate<S extends Record<string, any> = API.Service>({ name, access, agent }: {
    name: string;
    access?: API.SpaceAccessType | undefined;
    agent?: API.Agent<S> | undefined;
}): Promise<API.OwnedSpace<S>>;
export function fromMnemonic(mnemonic: string, { name, access, agent }: {
    name: string;
    access?: API.SpaceAccessType | undefined;
    agent?: API.Agent<API.Service> | undefined;
}): Promise<API.OwnedSpace<API.Service>>;
export function toMnemonic({ signer }: {
    signer: ED25519.EdSigner;
}): string;
export function createRecovery<S extends Record<string, any> = API.Service>(space: Model<S>, account: API.AccountDID): Promise<ED25519.Delegation<ED25519.Signer.Capabilities>>;
export const SESSION_LIFETIME: number;
export function createAuthorization<S extends Record<string, any> = API.Service>({ signer, name, access }: Model<S>, { audience, access: spaceAccess, expiration, }: {
    audience: API.Principal;
    access?: API.Access | undefined;
    expiration?: number | undefined;
}): Promise<ED25519.Delegation<ED25519.Signer.Capabilities>>;
/**
 * Represents an owned space, meaning a space for which we have a private key
 * and consequently have full authority over.
 *
 * @template {Record<string, any>} [S=API.Service]
 */
export class OwnedSpace<S extends Record<string, any> = API.Service> {
    /**
     * @param {Model<S>} model
     */
    constructor(model: Model<S>);
    model: Model<S>;
    get signer(): ED25519.EdSigner;
    get name(): string;
    get access(): API.PublicAccess | API.PrivateAccess<API.GoogleKMSEncryptionProvider>;
    did(): `did:key:${string}`;
    /**
     * Creates a renamed version of this space.
     *
     * @param {string} name
     */
    withName(name: string): API.OwnedSpace<API.Service>;
    /**
     * Saves account in the agent store so it can be accessed across sessions.
     *
     * @param {object} input
     * @param {API.Agent<S>} [input.agent]
     * @returns {Promise<API.Result<API.Unit, Error>>}
     */
    save({ agent }?: {
        agent?: API.Agent<S> | undefined;
    }): Promise<API.Result<API.Unit, Error>>;
    /**
     * @param {Authorization} authorization
     * @param {object} options
     * @param {API.Agent<S>} [options.agent]
     */
    provision({ proofs }: Authorization, { agent }?: {
        agent?: API.Agent<S> | undefined;
    }): Promise<ED25519.Result<{}, ED25519.Failure | ED25519.HandlerNotFound | ED25519.HandlerExecutionError | ED25519.InvalidAudience | ED25519.Unauthorized>> | {
        error: ED25519.Failure;
        ok?: undefined;
    };
    /**
     * Creates a (UCAN) delegation that gives full access to the space to the
     * specified `account`. At the moment we only allow `did:mailto` principal
     * to be used as an `account`.
     *
     * @param {API.AccountDID} account
     */
    createRecovery(account: API.AccountDID): Promise<ED25519.Delegation<ED25519.Signer.Capabilities>>;
    /**
     * Creates (UCAN) delegation that gives specified `agent` an access to
     * specified ability (passed as `access.can` field) on the this space.
     * Optionally, you can specify `access.expiration` field to set the
     *
     * @param {API.Principal} principal
     * @param {object} [input]
     * @param {API.Access} [input.access]
     * @param {API.UCAN.UTCUnixTimestamp} [input.expiration]
     */
    createAuthorization(principal: API.Principal, input?: {
        access?: API.Access | undefined;
        expiration?: number | undefined;
    }): Promise<ED25519.Delegation<ED25519.Signer.Capabilities>>;
    /**
     * Derives BIP39 mnemonic that can be used to recover the space.
     *
     * @returns {string}
     */
    toMnemonic(): string;
}
export function fromDelegation(delegation: API.Delegation): API.SharedSpace;
export function provision<S extends Record<string, any> = API.Service>(space: Space, { proofs, agent }: {
    proofs: API.Delegation[];
    agent: API.Agent<S>;
}): Promise<ED25519.Result<{}, ED25519.Failure | ED25519.HandlerNotFound | ED25519.HandlerExecutionError | ED25519.InvalidAudience | ED25519.Unauthorized>>;
/**
 * Represents a shared space, meaning a space for which we have a delegation
 * and consequently have limited authority over.
 */
export class SharedSpace {
    /**
     * @typedef {object} SharedSpaceModel
     * @property {API.SpaceDID} id
     * @property {API.Delegation} delegation
     * @property {{name?:string, access?:API.SpaceAccessType}} meta
     * @property {API.Agent} [agent]
     *
     * @param {SharedSpaceModel} model
     */
    constructor(model: {
        id: API.SpaceDID;
        delegation: API.Delegation;
        meta: {
            name?: string;
            access?: API.SpaceAccessType;
        };
        agent?: API.Agent<API.Service> | undefined;
    });
    model: {
        id: API.SpaceDID;
        delegation: API.Delegation;
        meta: {
            name?: string;
            access?: API.SpaceAccessType;
        };
        agent?: API.Agent<API.Service> | undefined;
    };
    get delegation(): ED25519.Delegation<ED25519.Signer.Capabilities>;
    get meta(): {
        name?: string;
        access?: API.SpaceAccessType;
    };
    get name(): string;
    get access(): API.PublicAccess | API.PrivateAccess<API.GoogleKMSEncryptionProvider>;
    did(): `did:key:${string}`;
    /**
     * @param {string} name
     */
    withName(name: string): API.SharedSpace;
}
/**
 * Data model for the (owned) space.
 */
export type Model<S extends Record<string, any> = API.Service> = {
    signer: ED25519.EdSigner;
    name: string;
    access?: API.SpaceAccessType;
    agent?: API.Agent<S>;
};
export type Authorization = {
    proofs: API.Delegation[];
};
export type Space = {
    did: () => API.SpaceDID;
};
import * as API from './types.js';
import * as ED25519 from '@ucanto/principal/ed25519';
//# sourceMappingURL=space.d.ts.map