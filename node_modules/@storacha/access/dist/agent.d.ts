/**
 * @typedef {API.Service} Service
 * @typedef {API.Receipt<any, any>} Receipt
 */
/**
 * Creates a Ucanto connection for the w3access API
 *
 * Usage:
 *
 * ```js
 * import { connection } from '@storacha/access/agent'
 * ```
 *
 * @template {API.DID} T - DID method
 * @template {Record<string, any>} [S=Service]
 * @param {object} [options]
 * @param {API.Principal<T>} [options.principal] - w3access API Principal
 * @param {URL} [options.url] - w3access API URL
 * @param {API.Transport.Channel<S>} [options.channel] - Ucanto channel to use
 * @param {typeof fetch} [options.fetch] - Fetch implementation to use
 * @returns {API.ConnectionView<S>}
 */
export function connection<T extends API.DID, S extends Record<string, any> = API.Service>(options?: {
    principal?: Client.Principal<T> | undefined;
    url?: URL | undefined;
    channel?: Client.Channel<S> | undefined;
    fetch?: typeof fetch | undefined;
}): API.ConnectionView<S>;
/**
 * Given a list of delegations, add to agent data spaces list.
 *
 * @deprecated - trying to remove explicit space tracking from Agent/AgentData
 * in favor of functions that derive the space set from access.delegations
 *
 * @template {Record<string, any>} [S=Service]
 * @param {Agent<S>} agent
 * @param {API.Delegation[]} delegations
 */
export function addSpacesFromDelegations<S extends Record<string, any> = API.Service>(agent: Agent<S>, delegations: API.Delegation[]): Promise<void>;
export * from "./types.js";
export * from "./delegations.js";
export * from "./agent-use-cases.js";
/**
 * Agent
 *
 * Usage:
 *
 * ```js
 * import { Agent } from '@storacha/access/agent'
 * ```
 *
 * @template {Record<string, any>} [S=Service]
 */
export class Agent<S extends Record<string, any> = API.Service> {
    /**
     * Create a new Agent instance, optionally with the passed initialization data.
     *
     * @template {Record<string, any>} [R=Service]
     * @param {Partial<import('./types.js').AgentDataModel>} [init]
     * @param {import('./types.js').AgentOptions<R> & import('./types.js').AgentDataOptions} [options]
     */
    static create<R extends Record<string, any> = API.Service>(init?: Partial<import("./types.js").AgentDataModel>, options?: import("./types.js").AgentOptions<R> & import("./types.js").AgentDataOptions): Promise<API.Agent<R>>;
    /**
     * Instantiate an Agent from pre-exported agent data.
     *
     * @template {Record<string, any>} [R=Service]
     * @param {import('./types.js').AgentDataExport} raw
     * @param {import('./types.js').AgentOptions<R> & import('./types.js').AgentDataOptions} [options]
     */
    static from<R extends Record<string, any> = API.Service>(raw: import("./types.js").AgentDataExport, options?: import("./types.js").AgentOptions<R> & import("./types.js").AgentDataOptions): API.Agent<R>;
    /**
     * @param {import('./agent-data.js').AgentData} data - Agent data
     * @param {import('./types.js').AgentOptions<S>} [options]
     */
    constructor(data: import("./agent-data.js").AgentData, options?: import("./types.js").AgentOptions<S>);
    url: URL;
    connection: Client.ConnectionView<S>;
    get issuer(): Client.Signer<`did:key:${string}`, Client.SigAlg>;
    get meta(): API.AgentMeta;
    get spaces(): Map<`did:${string}:${string}`, API.SpaceMeta>;
    did(): `did:key:${string}`;
    /**
     * Add a proof to the agent store.
     *
     * @param {API.Delegation} delegation
     */
    addProof(delegation: API.Delegation): Promise<{}>;
    /**
     * Adds set of proofs to the agent store.
     *
     * @param {Iterable<API.Delegation>} delegations
     */
    addProofs(delegations: Iterable<API.Delegation>): Promise<{}>;
    /**
     * Clean up any expired delegations.
     */
    removeExpiredDelegations(): Promise<void>;
    /**
     * Revoke a delegation by CID.
     *
     * If the delegation was issued by this agent (and therefore is stored in the
     * delegation store) you can just pass the CID. If not, or if the current agent's
     * delegation store no longer contains the delegation, you MUST pass a chain of
     * proofs that proves your authority to revoke this delegation as `options.proofs`.
     *
     * @param {API.UCANLink} delegationCID
     * @param {object} [options]
     * @param {API.Delegation[]} [options.proofs]
     */
    revoke(delegationCID: API.UCANLink, options?: {
        proofs?: Client.Delegation<Client.Capabilities>[] | undefined;
    }): Promise<Client.Result<{}, Client.Failure | Client.HandlerNotFound | Client.HandlerExecutionError | Client.InvalidAudience | Client.Unauthorized>>;
    /**
     * Get all the proofs matching the capabilities.
     *
     * Proofs are delegations with an audience matching agent DID, or with an
     * audience matching the session DID.
     *
     * Proof of session will also be included in the returned proofs if any
     * proofs matching the passed capabilities require it.
     *
     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the proofs.
     * @param {object} [options]
     * @param {API.DID|API.DID[]} [options.sessionProofIssuer] - only include session proofs for these issuer(s)
     */
    proofs(caps?: API.CapabilityQuery[], options?: {
        sessionProofIssuer?: `did:${string}:${string}` | `did:${string}:${string}`[] | undefined;
    }): Client.Delegation<Client.Capabilities>[];
    /**
     * Get delegations created by the agent for others.
     *
     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the delegations.
     */
    delegations(caps?: API.CapabilityQuery[]): Client.Delegation<Client.Capabilities>[];
    /**
     * Get delegations created by the agent for others and their metadata.
     *
     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the delegations.
     */
    delegationsWithMeta(caps?: API.CapabilityQuery[]): {
        delegation: API.Delegation;
        meta: API.DelegationMeta;
    }[];
    /**
     * Creates a space signer and a delegation to the agent
     *
     * @param {string} name
     * @param {object} [options]
     * @param {API.SpaceAccessType} [options.access] - The access type for the space. Defaults to { type: 'public' }.
     */
    createSpace(name: string, { access }?: {
        access?: API.SpaceAccessType | undefined;
    }): Promise<Space.OwnedSpace<S>>;
    /**
     * @param {string} secret
     * @param {object} options
     * @param {string} options.name - The name of the space.
     * @param {API.SpaceAccessType} [options.access] - The access type for the space. Defaults to { type: 'public' }.
     */
    recoverSpace(secret: string, { name, access }: {
        name: string;
        access?: API.SpaceAccessType | undefined;
    }): Promise<Space.OwnedSpace<API.Service>>;
    /**
     * Import a space from a delegation.
     *
     * @param {API.Delegation} delegation
     * @param {object} options
     * @param {string} [options.name]
     */
    importSpaceFromDelegation(delegation: API.Delegation, { name }?: {
        name?: string | undefined;
    }): Promise<Space.SharedSpace>;
    /**
     * Sets the current selected space
     *
     * Other methods will default to use the current space if no resource is defined
     *
     * @param {API.SpaceDID} space
     */
    setCurrentSpace(space: API.SpaceDID): Promise<`did:key:${string}`>;
    /**
     * Get current space DID
     */
    currentSpace(): `did:key:${string}` | undefined;
    /**
     * Get current space DID, proofs and abilities
     */
    currentSpaceWithMeta(): {
        did: `did:key:${string}`;
        proofs: Client.Delegation<Client.Capabilities>[];
        capabilities: any[];
        meta: API.SpaceMeta | undefined;
    } | undefined;
    /**
     *
     * @param {import('./types.js').DelegationOptions} options
     */
    delegate(options: import("./types.js").DelegationOptions): Promise<Client.Delegation<Client.Capabilities>>;
    /**
     * Invoke and execute the given capability on the Access service connection
     *
     * ```js
     *
     * await agent.invokeAndExecute(Space.recover, {
     *   nb: {
     *     identity: 'mailto: email@gmail.com',
     *   },
     * })
     *
     * // sugar for
     * const recoverInvocation = await agent.invoke(Space.recover, {
     *   nb: {
     *     identity: 'mailto: email@gmail.com',
     *   },
     * })
     *
     * await recoverInvocation.execute(agent.connection)
     * ```
     *
     * @template {API.Ability} A
     * @template {API.URI} R
     * @template {API.Caveats} C
     * @param {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>} cap
     * @param {API.InvokeOptions<A, R, API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>>} options
     * @returns {Promise<API.InferReceipt<API.Capability<A, R, C>, S>>}
     */
    invokeAndExecute<A extends API.Ability, R extends API.URI, C extends API.Caveats>(cap: API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>, options: API.InvokeOptions<A, R, API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>>): Promise<API.InferReceipt<API.Capability<A, R, C>, S>>;
    /**
     * Execute invocations on the agent's connection
     *
     * @example
     * ```js
     * const i1 = await agent.invoke(Space.info, {})
     * const i2 = await agent.invoke(Space.recover, {
     *   nb: {
     *     identity: 'mailto:hello@storacha.network',
     *   },
     * })
     *
     * const results = await agent.execute2(i1, i2)
     *
     * ```
     * @template {API.Capability} C
     * @template {API.Tuple<API.ServiceInvocation<C, S>>} I
     * @param {I} invocations
     */
    execute<C extends API.Capability, I extends API.Tuple<API.ServiceInvocation<C, S>>>(...invocations: I): Client.Await<Client.InferReceipts<I, S>>;
    /**
     * Creates an invocation for the given capability with Agent's proofs, service, issuer and space.
     *
     * @example
     * ```js
     * const recoverInvocation = await agent.invoke(Space.recover, {
     *   nb: {
     *     identity: 'mailto: email@gmail.com',
     *   },
     * })
     *
     * await recoverInvocation.execute(agent.connection)
     * // or
     * await agent.execute(recoverInvocation)
     * ```
     *
     * @template {API.Ability} A
     * @template {API.URI} R
     * @template {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>} CAP
     * @template {API.Caveats} [C={}]
     * @param {CAP} cap
     * @param {import('./types.js').InvokeOptions<A, R, CAP>} options
     */
    invoke<A extends API.Ability, R extends API.URI, CAP extends API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>, C extends API.Caveats = {}>(cap: CAP, options: import("./types.js").InvokeOptions<A, R, CAP>): Promise<Client.IssuedInvocationView<Client.InferInvokedCapability<CAP>>>;
    /**
     * Get Space information from Access service
     *
     * @param {API.URI<"did:">} [space]
     * @param {object} [options]
     * @param {string} [options.nonce]
     */
    getSpaceInfo(space?: API.URI<"did:">, options?: {
        nonce?: string | undefined;
    }): Promise<API.SpaceInfoResult>;
    #private;
}
export function importAuthorization(agent: Agent, { proofs }: {
    proofs: API.Delegation[];
}): Promise<API.Result<API.Unit, Error>>;
export type Service = API.Service;
export type Receipt = API.Receipt<any, any>;
import * as API from './types.js';
import * as Client from '@ucanto/client';
import { AgentData } from './agent-data.js';
import * as Access from './access.js';
import * as Space from './space.js';
import { Delegation } from '@ucanto/core';
import { Schema } from '@ucanto/core';
export { AgentData, Access, Space, Delegation, Schema };
//# sourceMappingURL=agent.d.ts.map