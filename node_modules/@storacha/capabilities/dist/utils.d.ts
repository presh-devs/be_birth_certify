/**
 * Check URI can be delegated.
 *
 * @param {string} [child]
 * @param {string} [parent]
 */
export function canDelegateURI(child?: string, parent?: string): {
    ok: {};
    error?: undefined;
} | {
    error: API.Failure;
    ok?: undefined;
};
/**
 * Checks that `with` on claimed capability is the same as `with`
 * in delegated capability. Note this will ignore `can` field.
 *
 * @param {API.ParsedCapability} child
 * @param {API.ParsedCapability} parent
 */
export function equalWith(child: API.ParsedCapability, parent: API.ParsedCapability): {
    error: API.Failure;
    ok?: undefined;
} | {
    ok: {};
    error?: undefined;
};
/**
 * @param {unknown} child
 * @param {unknown} parent
 * @param {string} constraint
 */
export function equal(child: unknown, parent: unknown, constraint: string): {
    error: API.Failure;
    ok?: undefined;
} | {
    ok: {};
    error?: undefined;
};
/**
 *
 * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'
 *
 * @param {import('@ucanto/interface').Ability} parent
 * @param {import('@ucanto/interface').Ability} child
 */
export function canDelegateAbility(parent: import("@ucanto/interface").Ability, child: import("@ucanto/interface").Ability): boolean;
export const ProviderDID: Schema.Schema<`did:web:${string}` & `did:${string}` & API.Phantom<{
    protocol: "did:";
}>, any>;
export const SpaceDID: Schema.Schema<`did:key:${string}` & `did:${string}` & API.Phantom<{
    protocol: "did:";
}>, any>;
export const AccountDID: Schema.Schema<`did:mailto:${string}` & `did:${string}` & API.Phantom<{
    protocol: "did:";
}>, any>;
export const Await: Schema.StructSchema<{
    'ucan/await': Schema.Schema<[string, API.Link<unknown, number, number, 0 | 1>], any>;
}, unknown>;
export function equalLink<T extends API.ParsedCapability<"store/add" | "store/get" | "store/remove", API.URI<"did:">, {
    link?: API.Link<unknown, number, number, 0 | 1>;
}>>(claimed: T, delegated: T): API.Result<{}, API.Failure>;
export function equalLinkOrDigestContent<T extends API.ParsedCapability<API.Ability, API.URI, {
    content?: API.UnknownLink | {
        digest: Uint8Array;
    };
}>>(claimed: T, delegated: T): API.Result<{}, API.Failure>;
export function equalBlob<T extends API.ParsedCapability<API.Ability, API.URI<"did:">, {
    blob: {
        digest: Uint8Array;
        size: number;
    };
}>>(claimed: T, delegated: T): API.Result<{}, API.Failure>;
export function equalBody<T extends API.ParsedCapability<"http/put", API.URI<"did:">, {
    body: {
        digest: Uint8Array;
        size: number;
    };
}>>(claimed: T, delegated: T): API.Result<{}, API.Failure>;
export function equalContent<T extends API.ParsedCapability<"blob/add" | "blob/remove" | "blob/allocate" | "blob/accept" | "http/put", API.URI<"did:">, {
    content: Uint8Array;
}>>(claimed: T, delegated: T): API.Result<{}, API.Failure>;
export function checkLink(claimed: API.UnknownLink, imposed: API.UnknownLink | undefined, at: string): API.Result<{}, API.Failure>;
export function and<T>(result: API.Result<T, API.Failure>): {
    error: API.Failure;
    ok?: undefined;
} | undefined;
import * as API from '@ucanto/interface';
import { Schema } from '@ucanto/validator';
//# sourceMappingURL=utils.d.ts.map