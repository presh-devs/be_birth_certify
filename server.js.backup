// Enhanced server.js with CONSISTENT certificate ID generation
import express from 'express';
import multer from 'multer';
import cors from 'cors';
import dotenv from 'dotenv';
import { create } from '@storacha/client';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { ethers } from 'ethers';
import PDFDocument from 'pdfkit';

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Configure multer for file uploads
const upload = multer({ 
  dest: 'uploads/',
  limits: {
    fileSize: 100 * 1024 * 1024 // 100MB limit
  }
});

// Initialize Storacha client
let storachaClient = null;
let currentSpace = null;

// Initialize Web3 provider (for NFT minting)
let provider = null;
let wallet = null;
let nftContract = null;

async function initializeStoracha() {
  try {
    console.log('üöÄ Initializing Storacha client...');
    
    storachaClient = await create();
    
    console.log('üìß Logging in with email...');
    const account = await storachaClient.login(process.env.STORACHA_EMAIL);
    console.log('‚úÖ Login successful');
    
    console.log('üí≥ Waiting for payment plan...');
    await account.plan.wait();
    console.log('‚úÖ Payment plan confirmed');
    
    try {
      currentSpace = await storachaClient.createSpace("birth-certificate-space", { account });
      console.log('üåå Created new space:', currentSpace.did());
    } catch (error) {
      if (error.message.includes('space already exists')) {
        console.log('üåå Using existing space');
      } else {
        throw error;
      }
    }
    
    console.log('‚úÖ Storacha initialized successfully');
    
  } catch (error) {
    console.error('‚ùå Failed to initialize Storacha:', error);
    process.exit(1);
  }
}

async function initializeWeb3() {
  try {
    console.log('üîó Initializing Web3...');
    
    // Initialize provider (you can use different networks)
    provider = new ethers.JsonRpcProvider(process.env.RPC_URL || 'https://polygon-mumbai.infura.io/v3/YOUR-PROJECT-ID');
    
    // Initialize wallet
    wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);
    
    // NFT Contract ABI (simplified)
    const nftABI = [
      "function mint(address to, string memory tokenURI) public returns (uint256)",
      "function tokenURI(uint256 tokenId) public view returns (string memory)",
      "function balanceOf(address owner) public view returns (uint256)",
      "function ownerOf(uint256 tokenId) public view returns (address)"
    ];
    
    // Initialize contract (deploy your own NFT contract or use existing)
    nftContract = new ethers.Contract(
      process.env.NFT_CONTRACT_ADDRESS || '0x0000000000000000000000000000000000000000',
      nftABI,
      wallet
    );
    
    console.log('‚úÖ Web3 initialized successfully');
    console.log('üìù Wallet address:', wallet.address);
    
  } catch (error) {
    console.error('‚ùå Failed to initialize Web3:', error);
    // Don't exit here, NFT minting is optional
  }
}

// Generate PDF Birth Certificate with CONSISTENT certificate ID
async function generateBirthCertificatePDF(birthData, certificateId) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({ margin: 50 });
      const chunks = [];
      
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      
      // Header
      doc.fontSize(24).font('Helvetica-Bold')
         .text('BIRTH CERTIFICATE', { align: 'center' });
      
      doc.moveDown(2);
      
      // Certificate details
      doc.fontSize(12).font('Helvetica');
      
      const details = [
        ['Certificate ID:', certificateId], // üîß USE THE PASSED CERTIFICATE ID
        ['Full Name:', `${birthData.firstName} ${birthData.middleName || ''} ${birthData.lastName}`],
        ['Date of Birth:', birthData.dateOfBirth],
        ['Place of Birth:', birthData.placeOfBirth],
        ['Mother\'s Name:', `${birthData.motherFirstName} ${birthData.motherLastName}`],
        ['Father\'s Name:', `${birthData.fatherFirstName} ${birthData.fatherLastName}`],
        ['Mother\'s NIN:', birthData.motherNIN],
        ['Father\'s NIN:', birthData.fatherNIN],
        ['Registration Date:', new Date().toLocaleDateString()],
      ];
      
      details.forEach(([label, value]) => {
        if (value) {
          doc.text(`${label.padEnd(20)} ${value}`, { continued: false });
          doc.moveDown(0.5);
        }
      });
      
      doc.moveDown(2);
      
      // Footer
      doc.fontSize(10)
         .text('This is a digitally generated birth certificate.', { align: 'center' })
         .text('Stored on IPFS and blockchain for authenticity.', { align: 'center' });
      
      if (birthData.ipfsCid) {
        doc.moveDown()
           .text(`IPFS CID: ${birthData.ipfsCid}`, { align: 'center' });
      }
      
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
}

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'ok', 
    storacha: storachaClient ? 'connected' : 'disconnected',
    web3: wallet ? 'connected' : 'disconnected',
    timestamp: new Date().toISOString()
  });
});

// Submit birth registration with document upload and NFT minting
app.post('/birth-registration', upload.single('supportingDocument'), async (req, res) => {
  try {
    const birthData = JSON.parse(req.body.birthData);
    
    console.log('üìã Processing birth registration:', birthData.firstName, birthData.lastName);

    if (!storachaClient) {
      return res.status(500).json({ error: 'Storacha client not initialized' });
    }

    // üîß GENERATE CERTIFICATE ID ONCE AT THE BEGINNING
    const certificateId = `BC-${Date.now()}`;
    console.log('üÜî Generated certificate ID:', certificateId);

    let supportingDocumentCid = null;
    
    // Upload supporting document if provided
    if (req.file) {
      console.log('üìÑ Uploading supporting document...');
      const fileBuffer = fs.readFileSync(req.file.path);
      const file = new File([fileBuffer], req.file.originalname, {
        type: req.file.mimetype
      });
      
      supportingDocumentCid = await storachaClient.uploadFile(file);
      fs.unlinkSync(req.file.path); // Clean up
      
      console.log('‚úÖ Supporting document uploaded:', supportingDocumentCid.toString());
    }

    // Generate PDF birth certificate with the SAME certificate ID
    console.log('üìú Generating birth certificate PDF with ID:', certificateId);
    const pdfBuffer = await generateBirthCertificatePDF({
      ...birthData,
      supportingDocumentCid: supportingDocumentCid?.toString()
    }, certificateId); // üîß PASS THE CERTIFICATE ID TO PDF GENERATION

    // Upload PDF to IPFS
    const pdfFile = new File([pdfBuffer], `birth-certificate-${certificateId}.pdf`, {
      type: 'application/pdf'
    });
    
    const certificateCid = await storachaClient.uploadFile(pdfFile);
    console.log('‚úÖ Birth certificate uploaded to IPFS:', certificateCid.toString());

    // Create metadata for NFT
    const metadata = {
      name: `Birth Certificate - ${birthData.firstName} ${birthData.lastName}`,
      description: `Official birth certificate for ${birthData.firstName} ${birthData.lastName}, born on ${birthData.dateOfBirth}`,
      image: `https://${certificateCid}.ipfs.storacha.link`,
      attributes: [
        { trait_type: "Certificate ID", value: certificateId }, // üîß ADD CERTIFICATE ID TO METADATA
        { trait_type: "Full Name", value: `${birthData.firstName} ${birthData.middleName || ''} ${birthData.lastName}`.trim() },
        { trait_type: "Date of Birth", value: birthData.dateOfBirth },
        { trait_type: "Place of Birth", value: birthData.placeOfBirth },
        { trait_type: "Certificate Type", value: "Birth Certificate" },
        { trait_type: "Issue Date", value: new Date().toISOString().split('T')[0] }
      ],
      external_url: `https://${certificateCid}.ipfs.storacha.link`,
      certificate_id: certificateId, // üîß INCLUDE CERTIFICATE ID IN METADATA
      certificate_cid: certificateCid.toString(),
      supporting_document_cid: supportingDocumentCid?.toString()
    };

    // Upload metadata to IPFS
    const metadataFile = new File([JSON.stringify(metadata, null, 2)], 'metadata.json', {
      type: 'application/json'
    });
    
    const metadataCid = await storachaClient.uploadFile(metadataFile);
    console.log('‚úÖ Metadata uploaded to IPFS:', metadataCid.toString());

    let nftTokenId = null;
    let nftTransactionHash = null;

    // Mint NFT if Web3 is configured and wallet address is provided
    if (nftContract && birthData.wallet && ethers.isAddress(birthData.wallet)) {
      try {
        console.log('üé® Minting NFT...');
        const tokenURI = `https://${metadataCid}.ipfs.storacha.link`;
        
        const tx = await nftContract.mint(birthData.wallet, tokenURI);
        await tx.wait();
        
        nftTransactionHash = tx.hash;
        
        // Get token ID from transaction receipt
        const receipt = await provider.getTransactionReceipt(tx.hash);
        const mintEvent = receipt.logs.find(log => log.topics[0] === ethers.id("Transfer(address,address,uint256)"));
        
        if (mintEvent) {
          nftTokenId = parseInt(mintEvent.topics[3], 16);
        }
        
        console.log('‚úÖ NFT minted successfully:', nftTokenId);
        
      } catch (nftError) {
        console.error('‚ùå NFT minting failed:', nftError);
        // Continue without NFT - the certificate is still valid
      }
    }

    // üîß RETURN RESPONSE WITH CONSISTENT CERTIFICATE ID
    const response = {
      success: true,
      certificateId: certificateId, // üîß USE THE SAME CERTIFICATE ID
      certificate: {
        cid: certificateCid.toString(),
        gatewayUrl: `https://${certificateCid}.ipfs.storacha.link`,
        ipfsUrl: `ipfs://${certificateCid}`
      },
      metadata: {
        cid: metadataCid.toString(),
        gatewayUrl: `https://${metadataCid}.ipfs.storacha.link`,
        ipfsUrl: `ipfs://${metadataCid}`
      },
      supportingDocument: supportingDocumentCid ? {
        cid: supportingDocumentCid.toString(),
        gatewayUrl: `https://${supportingDocumentCid}.ipfs.storacha.link`,
        ipfsUrl: `ipfs://${supportingDocumentCid}`
      } : null,
      nft: nftTokenId ? {
        tokenId: nftTokenId,
        transactionHash: nftTransactionHash,
        contractAddress: process.env.NFT_CONTRACT_ADDRESS,
        ownerAddress: birthData.wallet
      } : null,
      registeredAt: new Date().toISOString()
    };

    console.log('üéâ Birth registration completed successfully with certificate ID:', certificateId);
    res.json(response);

  } catch (error) {
    console.error('‚ùå Birth registration failed:', error);
    
    // Clean up temporary file on error
    if (req.file && fs.existsSync(req.file.path)) {
      fs.unlinkSync(req.file.path);
    }

    res.status(500).json({
      error: 'Birth registration failed',
      message: error.message
    });
  }
});

// Get certificate by CID
app.get('/certificate/:cid', async (req, res) => {
  try {
    const { cid } = req.params;
    
    const gatewayUrl = `https://${cid}.ipfs.storacha.link`;

    res.json({
      cid,
      gatewayUrl,
      ipfsUrl: `ipfs://${cid}`,
      type: 'birth_certificate'
    });

  } catch (error) {
    console.error('‚ùå Failed to get certificate:', error);
    res.status(500).json({
      error: 'Failed to get certificate',
      message: error.message
    });
  }
});

// Verify NFT ownership
app.get('/verify-nft/:tokenId', async (req, res) => {
  try {
    const { tokenId } = req.params;
    
    if (!nftContract) {
      return res.status(500).json({ error: 'NFT contract not initialized' });
    }

    const owner = await nftContract.ownerOf(tokenId);
    const tokenURI = await nftContract.tokenURI(tokenId);

    res.json({
      tokenId,
      owner,
      tokenURI,
      verified: true
    });

  } catch (error) {
    console.error('‚ùå Failed to verify NFT:', error);
    res.status(500).json({
      error: 'Failed to verify NFT',
      message: error.message,
      verified: false
    });
  }
});

// Generate wallet address (simple random wallet)
app.post('/generate-wallet', (req, res) => {
  try {
    const newWallet = ethers.Wallet.createRandom();
    
    res.json({
      address: newWallet.address,
      privateKey: newWallet.privateKey, // ‚ö†Ô∏è In production, never return private keys
      mnemonic: newWallet.mnemonic?.phrase
    });

  } catch (error) {
    console.error('‚ùå Failed to generate wallet:', error);
    res.status(500).json({
      error: 'Failed to generate wallet',
      message: error.message
    });
  }
});

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('üí• Unhandled error:', error);
  res.status(500).json({
    error: 'Internal server error',
    message: error.message
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    error: 'Not found',
    message: `Route ${req.method} ${req.path} not found`
  });
});

// Start server
async function startServer() {
  try {
    // Create uploads directory if it doesn't exist
    if (!fs.existsSync('uploads')) {
      fs.mkdirSync('uploads');
    }

    // Initialize Storacha first
    await initializeStoracha();
    
    // Initialize Web3 (optional)
    await initializeWeb3();
    
    // Start the server
    app.listen(PORT, () => {
      console.log(`üöÄ Server running on http://localhost:${PORT}`);
      console.log('üìã Available endpoints:');
      console.log('  GET  /health - Health check');
      console.log('  POST /birth-registration - Submit birth registration with NFT minting');
      console.log('  GET  /certificate/:cid - Get certificate info');
      console.log('  GET  /verify-nft/:tokenId - Verify NFT ownership');
      console.log('  POST /generate-wallet - Generate new wallet');
    });

  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
}

startServer();